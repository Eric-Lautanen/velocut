// crates/velocut-core/src/transitions/mod.rs
//
// Transition system for VeloCut.
//
// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  HOW TO ADD A TRANSITION â€” one line, everything else is auto â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
//   1. Create `transitions/my_transition.rs`, impl `VideoTransition`
//      (all 5 required methods: kind, label, icon, build, apply).
//
//   2. Add ONE line to `declare_transitions!` below:
//        my_transition::MyTransition => MyKind,
//
//   Done. TransitionKind variant, registry, badge, tooltip, popup button,
//   duration slider, encode, and preview all pick it up automatically.
//   No other changes needed anywhere.
//
// â”€â”€ Architecture â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
//   Layer 1 â€” Serialized types  (`TransitionKind`, `TransitionType`,
//             `TimelineTransition`, `ClipTransition`)
//             These are written to the project file. Never rename/remove
//             existing TransitionKind variants without a migration path.
//
//   Layer 2 â€” `VideoTransition` trait
//             Pure pixel algorithm. Receives packed YUV420P slices + alpha,
//             returns blended packed slice. No FFmpeg types cross this boundary.
//
//   Layer 3 â€” Registry  (`registered()` for UI, `registry()` for encode)
//             Built from `declare_transitions!`. UI iterates `registered()`;
//             encode does O(1) lookup via `registry()`. Cut is never in either
//             â€” callers short-circuit on `TransitionKind::Cut`.

pub mod helpers;

use std::collections::HashMap;
use uuid::Uuid;
use serde::{Deserialize, Serialize};

// â”€â”€ Drop-in registration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// To add a transition:     append `module::Struct => KindVariant,` here.
// To disable a transition: comment it out. The KindVariant must stay in the
//                          serialized enum (generated below) for project-file
//                          safety, but the impl can be absent.
//
// The macro generates ALL of:
//   â€¢ `mod` declarations for each module
//   â€¢ The entire `TransitionKind` enum (Cut is always prepended)
//   â€¢ `make_entries()` used by `registered()` and `registry()`
//
// Nothing else in this file needs to change when a transition is added.

macro_rules! declare_transitions {
    ( $( $module:ident :: $struct:ident => $kind:ident ),* $(,)? ) => {
        $( mod $module; )*

        /// Identifies which algorithm to use. Generated by `declare_transitions!`.
        ///
        /// `Cut` is always present. All other variants come from the macro.
        /// `Copy` so the registry HashMap can key on it cheaply.
        ///
        /// **Never rename or remove existing variants** â€” they are written to
        /// project files and must deserialize cleanly forever.
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum TransitionKind {
            Cut,
            $( $kind, )*
        }

        fn make_entries() -> Vec<Box<dyn VideoTransition>> {
            vec![ $( Box::new($module::$struct) ),* ]
        }
    };
}

declare_transitions! {
    crossfade::Crossfade       => Crossfade,
    dip_to_black::DipToBlack   => DipToBlack,
    // wipe::Wipe               => Wipe,
}

// â”€â”€ Serialized project types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// Serialized transition stored in `ProjectState`.
///
/// A plain struct â€” not a per-transition enum â€” because every transition shares
/// the same runtime parameter (`duration_secs: f32`). This means this struct
/// never needs to change when a new transition is added. Only the one line in
/// `declare_transitions!` changes.
///
/// Written to the project file. `kind` identifies the algorithm; `duration_secs`
/// is the overlap length in seconds (0.0 for Cut, ignored).
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TransitionType {
    pub kind: TransitionKind,
    pub duration_secs: f32,
}

impl Default for TransitionType {
    fn default() -> Self {
        TransitionType { kind: TransitionKind::Cut, duration_secs: 0.0 }
    }
}

impl TransitionType {
    /// General constructor â€” used by `VideoTransition::build()` impls.
    pub fn new(kind: TransitionKind, duration_secs: f32) -> Self {
        TransitionType { kind, duration_secs }
    }

    /// Convenience constructor for a hard cut.
    pub fn cut() -> Self {
        TransitionType { kind: TransitionKind::Cut, duration_secs: 0.0 }
    }
}

/// Stored in `ProjectState`, serialized with the project.
///
/// Keyed by the UUID of the preceding `TimelineClip` so it survives clip
/// reordering without going stale.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct TimelineTransition {
    pub after_clip_id: Uuid,
    pub kind: TransitionType,
}

/// Encode-only â€” built by `begin_render`, passed through `EncodeSpec`.
/// Not serialized.
#[derive(Clone, Debug)]
pub struct ClipTransition {
    /// Index into the sorted clip Vec (0 = between clips[0] and clips[1]).
    pub after_clip_index: usize,
    pub kind: TransitionType,
}

// â”€â”€ VideoTransition trait â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// Algorithm contract for all video transitions.
///
/// Implementors are zero-size (or config) structs â€” they hold no per-clip state.
/// Runtime parameters arrive through `TransitionType` at the call site; the
/// trait only receives what it needs to blend two frames.
///
/// # Buffer contract
/// `frame_a` and `frame_b` are packed YUV420P byte slices:
///   `[Y: wÃ—h bytes][U: (w/2)Ã—(h/2) bytes][V: (w/2)Ã—(h/2) bytes]`
/// No stride padding. Produce them with `velocut_media::helpers::yuv::extract_yuv`
/// and write results back with `write_yuv`.
///
/// # Alpha convention
/// `alpha = 0.0` â†’ 100 % frame_a (outgoing clip)
/// `alpha = 1.0` â†’ 100 % frame_b (incoming clip)
/// Caller computes alpha from frame index and total overlap frame count via
/// `transitions::helpers::frame_alpha`.
///
/// # Performance
/// `apply()` is called once per blended frame. All inner loops must live
/// *inside* the impl â€” never make repeated trait calls from a pixel loop.
pub trait VideoTransition: Send + Sync {
    /// Discriminant for registry lookup. Must match the `TransitionKind`
    /// variant declared for this transition in `declare_transitions!`.
    fn kind(&self) -> TransitionKind;

    /// Human-readable label shown in the UI picker (e.g. `"Dissolve"`).
    fn label(&self) -> &'static str;

    /// Emoji badge shown on the timeline clip block when this transition is
    /// active (e.g. `"ðŸŒ«ï¸"`). Keep it one glyph wide.
    fn icon(&self) -> &'static str;

    /// Default overlap duration in seconds pre-filled in the UI when the user
    /// first selects this transition.
    fn default_duration_secs(&self) -> f32 { 0.5 }

    /// Construct the serialized `TransitionType` for this transition.
    ///
    /// Called by the UI when the user selects or adjusts a transition. The UI
    /// **never** constructs `TransitionType` directly â€” always calls this so
    /// the kind and duration are encapsulated in the impl.
    ///
    /// Implementations should return: `TransitionType::new(self.kind(), duration_secs)`
    fn build(&self, duration_secs: f32) -> TransitionType;

    /// Blend `frame_a` and `frame_b` at `alpha` and return the packed result.
    ///
    /// `width` / `height` are luma plane dimensions in pixels.
    /// UV dims are `(width / 2, height / 2)`.
    fn apply(
        &self,
        frame_a: &[u8],
        frame_b: &[u8],
        width:   u32,
        height:  u32,
        alpha:   f32,
    ) -> Vec<u8>;
}

// â”€â”€ Registry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// All registered transitions in stable display order.
///
/// Use for UI iteration (picker buttons, badge lookup). Cut is not included â€”
/// it is always a hardcoded "remove transition" action in the UI.
pub fn registered() -> Vec<Box<dyn VideoTransition>> {
    make_entries()
}

/// All registered transitions keyed by `TransitionKind` for O(1) lookup.
///
/// Use during encode and preview. Cut has no entry â€” short-circuit on
/// `TransitionKind::Cut` before calling this.
pub fn registry() -> HashMap<TransitionKind, Box<dyn VideoTransition>> {
    make_entries().into_iter().map(|t| (t.kind(), t)).collect()
}